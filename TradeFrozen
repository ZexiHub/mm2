

-- WindUI
local WindUI = loadstring(game:HttpGet("https://github.com/Footagesus/WindUI/releases/latest/download/main.lua"))()

-- Locals
local Players = game:GetService("Players")
local RunService = game:GetService("RunService")
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local Workspace = game:GetService("Workspace")
local CurrentCamera = Workspace.CurrentCamera
local LocalPlayer = Players.LocalPlayer

local CoreGui = game:GetService("CoreGui")

function gradient(text, startColor, endColor)
    local result = ""
    local length = #text

    for i = 1, length do
        local t = (i - 1) / math.max(length - 1, 1)
        local r = math.floor((startColor.R + (endColor.R - startColor.R) * t) * 255)
        local g = math.floor((startColor.G + (endColor.G - startColor.G) * t) * 255)
        local b = math.floor((startColor.B + (endColor.B - startColor.B) * t) * 255)

        local char = text:sub(i, i)
        result = result .. "<font color=\"rgb(" .. r ..", " .. g .. ", " .. b .. ")\">" .. char .. "</font>"
    end

    return result
end

local Confirmed = false

WindUI:Popup({
    Title = gradient("KANEKI HUB", Color3.fromHex("#eb1010"), Color3.fromHex("#1023eb")),
    Icon = "info",
    Content = gradient("This script made by", Color3.fromHex("#10eb3c"), Color3.fromHex("#67c97a")) .. gradient(" Kxrma", Color3.fromHex("#001e80"), Color3.fromHex("#16f2d9")),
    Buttons = {
        {
            Title = gradient("Cancel", Color3.fromHex("#e80909"), Color3.fromHex("#630404")),
            Callback = function() end,
            Variant = "Tertiary", -- Primary, Secondary, Tertiary
        },
        {
            Title = gradient("Load", Color3.fromHex("#90f09e"), Color3.fromHex("#13ed34")),
            Callback = function() Confirmed = true end,
            Variant = "Secondary", -- Primary, Secondary, Tertiary
        }
    }
})

repeat task.wait() until Confirmed

WindUI:Notify({
    Title = gradient("KANEKI HUB", Color3.fromHex("#eb1010"), Color3.fromHex("#1023eb")),
    Content = "Welcome to Kaneki Hub!",
    Icon = "check-circle",
    Duration = 3,
})

-- Window
local Window = WindUI:CreateWindow({
    Title = gradient("KanekiHub [Beta] by Kxrma", Color3.fromHex("#001e80"), Color3.fromHex("#16f2d9")),
    Icon = "infinity",
    Author = gradient("Murder Mystery 2", Color3.fromHex("#1bf2b2"), Color3.fromHex("#1bcbf2")),
    Folder = "WindUI",
    Size = UDim2.fromOffset(300, 270),
    Transparent = true,
    Theme = "Dark",
    SideBarWidth = 200,
    UserEnabled = true,
    HasOutline = true,
})

-- Open Button
Window:EditOpenButton({
    Title = "Open UI",
    Icon = "monitor",
    CornerRadius = UDim.new(2, 6),
    StrokeThickness = 2,
    Color = ColorSequence.new(
        Color3.fromHex("1E213D"),
        Color3.fromHex("1F75FE")
    ),
    Draggable = true,
})

-- Tabs
local Tabs = {
    MainTab = Window:Tab({ Title = gradient("DUPE WEAPONS", Color3.fromHex("#ffffff"), Color3.fromHex("#636363")), Icon = "terminal" }),
    CharacterTab = Window:Tab({ Title = gradient("CHARACTER", Color3.fromHex("#ffffff"), Color3.fromHex("#636363")), Icon = "file-cog" }),
    TeleportTab = Window:Tab({ Title = gradient("TELEPORT", Color3.fromHex("#ffffff"), Color3.fromHex("#636363")), Icon = "user" }),
    EspTab = Window:Tab({ Title = gradient("ESP", Color3.fromHex("#ffffff"), Color3.fromHex("#636363")), Icon = "eye" }),
    AimbotTab = Window:Tab({ Title = gradient("AIMBOT", Color3.fromHex("#ffffff"), Color3.fromHex("#636363")), Icon = "arrow-right" }),
    AutoFarm = Window:Tab({ Title = gradient("AUTOFARM", Color3.fromHex("#ffffff"), Color3.fromHex("#636363")), Icon = "sword"}),
    InnocentTab = Window:Tab({
    Title = gradient("INNOCENT", Color3.fromHex("#0ff707"), Color3.fromHex("#1e690c")),
    Icon = "circle"
}),
MurderTab = Window:Tab({
    Title = gradient("MURDER", Color3.fromHex("#e80909"), Color3.fromHex("#630404")),
    Icon = "circle"
}),
SheriffTab = Window:Tab({
    Title = gradient("SHERIFF", Color3.fromHex("#001e80"), Color3.fromHex("#16f2d9")),
    Icon = "circle"
}),
gh = Window:Divider(),
    ServerTab = Window:Tab({ Title = gradient("SERVER", Color3.fromHex("#ffffff"), Color3.fromHex("#636363")), Icon = "atom", }),
    beed = Window:Divider(),
    SettingsTab = Window:Tab({ Title = gradient("SETTINGS", Color3.fromHex("#ffffff"), Color3.fromHex("#636363")), Icon = "code" }),
    ChangelogsTab = Window:Tab({ Title = gradient("CHANGELOGS", Color3.fromHex("#ffffff"), Color3.fromHex("#636363")), Icon = "info"}),
    SocialsTab = Window:Tab({ Title = gradient("SOCIALS", Color3.fromHex("#ffffff"), Color3.fromHex("#636363")), Icon = "star"}),
    b = Window:Divider(),
    WindowTab = Window:Tab({ Title = gradient("CONFIGURATION", Color3.fromHex("#ffffff"), Color3.fromHex("#636363")), Icon = "settings", Desc = "Manage window settings and file configurations." }),
    CreateThemeTab = Window:Tab({ Title = gradient("THEMES", Color3.fromHex("#ffffff"), Color3.fromHex("#636363")), Icon = "palette", Desc = "Design and apply custom themes." }),
}
-- DUPE WEAPONS TAB (Premium Locked)
Tabs.MainTab:Section({ Title = gradient("Weapon Duplication", Color3.fromHex("#ffcc00"), Color3.fromHex("#ff6600")) })

Tabs.MainTab:Paragraph({
    Title = gradient("Premium Feature Locked", Color3.fromHex("#ff3333"), Color3.fromHex("#990000")),
    Desc = gradient("Unlock Weapon Duplication\nDuplicate any weapon instantly!\nMultiply your inventory value.", Color3.fromHex("#ffffff"), Color3.fromHex("#cccccc")),
    Image = "lock",
    Color = "Blue"
})

Tabs.MainTab:Button({
    Title = gradient("Unlock with Robux - 199 R$", Color3.fromHex("#00ff00"), Color3.fromHex("#00cc00")),
    Variant = "Primary",
    Icon = "gem",
    Callback = function()
        WindUI:Notify({
            Title = "Robux Purchase",
            Content = "Wait...",
            Icon = "shopping-cart",
            Duration = 4
        })
        -- Simule l'achat (tu peux connecter Ãƒ  un vrai systÃƒÂ¨me plus tard)
        task.wait(1)
        setclipboard("https://www.roblox.com/games/104253700549488/SdkAz1s-Place") 
            WindUI:Notify({
            Title = "Pay 199 Robux for Access",
            Content = "When you have payed Dm @Kxrmanana on discord",
            Icon = "x-circle",
            Duration = 3
        })
    end
})

Tabs.MainTab:Button({
    Title = gradient("Unlock with Paypal -1$50", Color3.fromHex("#ff8800"), Color3.fromHex("#cc5500")),
    Variant = "Secondary",
    Icon = "bitcoin",
    Callback = function()
        WindUI:Notify({
            Title = "Paypal Payment",
            Content = "Wait..",
            Icon = "external-link",
            Duration = 4
        })
        task.wait(1)
        -- Remplace par ton lien de paiement crypto
        setclipboard("https://paypal.me/younesbarrija597")
        WindUI:Notify({
            Title = "Link copied in your clipboard",
            Content = "When you payed dm @Kxrmanana on discord",
            Icon = "check-circle",
            Duration = 3
        })
    end
})

Tabs.MainTab:Paragraph({
    Title = gradient("Premium Benefits:", Color3.fromHex("#00ffaa"), Color3.fromHex("#00aa77")),
    Desc = 
        "Duplicate any weapon\n"..
        "Bulk inventory duplication\n"..
        "No detection risk\n"..
        "Instant processing",
    Image = "star",
    Color = "Green"
})
-- Character
local Players = game:GetService("Players")
local RunService = game:GetService("RunService")
local LocalPlayer = Players.LocalPlayer

local CharacterSettings = {
    WalkSpeed = {Value = 16, Default = 16, Locked = false},
    JumpPower = {Value = 50, Default = 50, Locked = false}
}

local function updateCharacter()
    local character = LocalPlayer.Character
    local humanoid = character:FindFirstChildOfClass("Humanoid")
    if humanoid then
        if not CharacterSettings.WalkSpeed.Locked then
            humanoid.WalkSpeed = CharacterSettings.WalkSpeed.Value
        end
        if not CharacterSettings.JumpPower.Locked then
            humanoid.JumpPower = CharacterSettings.JumpPower.Value
        end
    end
end
Tabs.CharacterTab:Section({Title = gradient("Walkspeed", Color3.fromHex("#ff0000"), Color3.fromHex("#300000"))})

Tabs.CharacterTab:Slider({
    Title = "Walkspeed",
    Value = {Min = 0, Max = 200, Default = 16},
    Callback = function(value)
        CharacterSettings.WalkSpeed.Value = value
        updateCharacter()
    end
})

Tabs.CharacterTab:Button({
    Title = "Reset walkspeed",
    Callback = function()
        CharacterSettings.WalkSpeed.Value = CharacterSettings.WalkSpeed.Default
        updateCharacter()
    end
})

Tabs.CharacterTab:Toggle({
    Title = "Block walkspeed",
    Default = false,
    Callback = function(state)
        CharacterSettings.WalkSpeed.Locked = state
        updateCharacter()
    end
})

Tabs.CharacterTab:Section({Title = gradient("JumpPower", Color3.fromHex("#001aff"), Color3.fromHex("#020524"))})

Tabs.CharacterTab:Slider({
    Title = "Jumppower",
    Value = {Min = 0, Max = 200, Default = 50},
    Callback = function(value)
        CharacterSettings.JumpPower.Value = value
        updateCharacter()
    end
})


Tabs.CharacterTab:Button({
    Title = "Reset jumppower",
    Callback = function()
        CharacterSettings.JumpPower.Value = CharacterSettings.JumpPower.Default
        updateCharacter()
    end
})

Tabs.CharacterTab:Toggle({
    Title = "Block jumppower",
    Default = false,
    Callback = function(state)
        CharacterSettings.JumpPower.Locked = state
        updateCharacter()
    end
})

-- ESP
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local Players = game:GetService("Players")
local RunService = game:GetService("RunService")
local LP = Players.LocalPlayer

local ESPConfig = {
    HighlightMurderer = false,
    HighlightInnocent = false,
    HighlightSheriff = false
}

local Murder, Sheriff, Hero
local roles = {}

function CreateHighlight(player)
    if player ~= LP and player.Character and not player.Character:FindFirstChild("Highlight") then
        local highlight = Instance.new("Highlight")
        highlight.Parent = player.Character
        highlight.Adornee = player.Character
        highlight.DepthMode = Enum.HighlightDepthMode.AlwaysOnTop
        return highlight
    end
    return player.Character and player.Character:FindFirstChild("Highlight")
end

function RemoveAllHighlights()
    for _, player in pairs(Players:GetPlayers()) do
        if player.Character and player.Character:FindFirstChild("Highlight") then
            player.Character.Highlight:Destroy()
        end
    end
end

function UpdateHighlights()
    for _, player in pairs(Players:GetPlayers()) do
        if player ~= LP and player.Character then
            local highlight = player.Character:FindFirstChild("Highlight")
            if not (ESPConfig.HighlightMurderer or ESPConfig.HighlightInnocent or ESPConfig.HighlightSheriff) then
                if highlight then
                    highlight:Destroy()
                end
                return
            end
            
            local shouldHighlight = false
            local color = Color3.new(0, 1, 0)
            if player.Name == Murder and IsAlive(player) and ESPConfig.HighlightMurderer then
                color = Color3.fromRGB(255, 0, 0)
                shouldHighlight = true
            elseif player.Name == Sheriff and IsAlive(player) and ESPConfig.HighlightSheriff then
                color = Color3.fromRGB(0, 0, 255)
                shouldHighlight = true
            elseif ESPConfig.HighlightInnocent and IsAlive(player) and 
                   player.Name ~= Murder and player.Name ~= Sheriff and player.Name ~= Hero then
                color = Color3.fromRGB(0, 255, 0)
                shouldHighlight = true
            elseif player.Name == Hero and IsAlive(player) and not IsAlive(game.Players[Sheriff]) and ESPConfig.HighlightSheriff then
                color = Color3.fromRGB(255, 250, 0)
                shouldHighlight = true
            end
            
            if shouldHighlight then
                highlight = CreateHighlight(player)
                if highlight then
                    highlight.FillColor = color
                    highlight.OutlineColor = color
                    highlight.Enabled = true
                end
            elseif highlight then
                highlight.Enabled = false
            end
        end
    end
end

function IsAlive(player)
    for name, data in pairs(roles) do
        if player.Name == name then
            return not data.Killed and not data.Dead
        end
    end
    return false
end

local function UpdateRoles()
    roles = ReplicatedStorage:FindFirstChild("GetPlayerData", true):InvokeServer()
    for name, data in pairs(roles) do
        if data.Role == "Murderer" then
            Murder = name
        elseif data.Role == 'Sheriff' then
            Sheriff = name
        elseif data.Role == 'Hero' then
            Hero = name
        end
    end
end

Tabs.EspTab:Section({Title = gradient("Special ESP", Color3.fromHex("#b914fa"), Color3.fromHex("#7023c2"))})

Tabs.EspTab:Toggle({
    Title = gradient("Higlight Murder", Color3.fromHex("#e80909"), Color3.fromHex("#630404")),
    Default = false,
    Callback = function(state) 
        ESPConfig.HighlightMurderer = state
        if not state then UpdateHighlights() end
    end
})

Tabs.EspTab:Toggle({
    Title = gradient("Highlight Innocent", Color3.fromHex("#0ff707"), Color3.fromHex("#1e690c")),
    Default = false,
    Callback = function(state) 
        ESPConfig.HighlightInnocent = state
        if not state then UpdateHighlights() end
    end
})

Tabs.EspTab:Toggle({
    Title = gradient("Highlight Sheriff", Color3.fromHex("#001e80"), Color3.fromHex("#16f2d9")),
    Default = false,
    Callback = function(state) 
        ESPConfig.HighlightSheriff = state
        if not state then UpdateHighlights() end
    end
})

local gunDropESPEnabled = false
local gunDropHighlight = nil

-- ÃÂ¡ÃÂ¿ÃÂ¸Ã‘ÂÃÂ¾ÃÂº ÃÂ²Ã‘ÂÃÂµÃ‘â€¦ ÃÂ²ÃÂ¾ÃÂ·ÃÂ¼ÃÂ¾ÃÂ¶ÃÂ½Ã‘â€¹Ã‘â€¦ ÃÂºÃÂ°Ã‘â‚¬Ã‘â€š
local mapPaths = {
    "ResearchFacility", "Hospital3", "MilBase", "House2", 
    "Workplace", "Mansion2", "BioLab", "Hotel", 
    "Factory", "Bank2", "PoliceStation"
}

-- ÃÂ¤Ã‘Æ’ÃÂ½ÃÂºÃ‘â€ ÃÂ¸Ã‘Â Ã‘ÂÃÂ¾ÃÂ·ÃÂ´ÃÂ°ÃÂ½ÃÂ¸Ã‘Â ÃÂ¿ÃÂ¾ÃÂ´Ã‘ÂÃÂ²ÃÂµÃ‘â€šÃÂºÃÂ¸ ÃÂ´ÃÂ»Ã‘Â GunDrop
local function createGunDropHighlight(gunDrop)
    if gunDropESPEnabled and gunDrop and not gunDrop:FindFirstChild("GunDropHighlight") then
        local highlight = Instance.new("Highlight")
        highlight.Name = "GunDropHighlight"
        highlight.FillColor = Color3.fromRGB(255, 215, 0) -- Ãâ€”ÃÂ¾ÃÂ»ÃÂ¾Ã‘â€šÃÂ¾ÃÂ¹ Ã‘â€ ÃÂ²ÃÂµÃ‘â€š
        highlight.OutlineColor = Color3.fromRGB(255, 165, 0)
        highlight.Adornee = gunDrop
        highlight.Parent = gunDrop
    end
end

-- ÃÂ¤Ã‘Æ’ÃÂ½ÃÂºÃ‘â€ ÃÂ¸Ã‘Â ÃÂ¾ÃÂ±ÃÂ½ÃÂ¾ÃÂ²ÃÂ»ÃÂµÃÂ½ÃÂ¸Ã‘Â ESP
local function updateGunDropESP()
    -- ÃÂ£ÃÂ´ÃÂ°ÃÂ»Ã‘ÂÃÂµÃÂ¼ Ã‘ÂÃ‘â€šÃÂ°Ã‘â‚¬Ã‘â€¹ÃÂµ ÃÂ¿ÃÂ¾ÃÂ´Ã‘ÂÃÂ²ÃÂµÃ‘â€šÃÂºÃÂ¸
    for _, mapName in pairs(mapPaths) do
        local map = workspace:FindFirstChild(mapName)
        if map then
            local gunDrop = map:FindFirstChild("GunDrop")
            if gunDrop and gunDrop:FindFirstChild("GunDropHighlight") then
                gunDrop.GunDropHighlight:Destroy()
            end
        end
    end

    -- ÃÂ¡ÃÂ¾ÃÂ·ÃÂ´ÃÂ°ÃÂµÃÂ¼ ÃÂ½ÃÂ¾ÃÂ²Ã‘â€¹ÃÂµ ÃÂ¿ÃÂ¾ÃÂ´Ã‘ÂÃÂ²ÃÂµÃ‘â€šÃÂºÃÂ¸ ÃÂµÃ‘ÂÃÂ»ÃÂ¸ ESP ÃÂ²ÃÂºÃÂ»Ã‘Å½Ã‘â€¡ÃÂµÃÂ½
    if gunDropESPEnabled then
        for _, mapName in pairs(mapPaths) do
            local map = workspace:FindFirstChild(mapName)
            if map then
                local gunDrop = map:FindFirstChild("GunDrop")
                if gunDrop then
                    createGunDropHighlight(gunDrop)
                end
            end
        end
    end
end

-- ÃÅ“ÃÂ¾ÃÂ½ÃÂ¸Ã‘â€šÃÂ¾Ã‘â‚¬ÃÂ¸ÃÂ½ÃÂ³ ÃÂ¿ÃÂ¾Ã‘ÂÃÂ²ÃÂ»ÃÂµÃÂ½ÃÂ¸Ã‘Â GunDrop ÃÂ½ÃÂ° ÃÂ²Ã‘ÂÃÂµÃ‘â€¦ ÃÂºÃÂ°Ã‘â‚¬Ã‘â€šÃÂ°Ã‘â€¦
local function monitorGunDrops()
    for _, mapName in pairs(mapPaths) do
        local map = workspace:FindFirstChild(mapName)
        if map then
            map.ChildAdded:Connect(function(child)
                if child.Name == "GunDrop" then
                    createGunDropHighlight(child)
                end
            end)
        end
    end
end

monitorGunDrops()

Tabs.EspTab:Toggle({
    Title = gradient("GunDrop Highlight", Color3.fromHex("#ffff00"), Color3.fromHex("#4f4f00")),
    Default = false,
    Callback = function(state)
        gunDropESPEnabled = state
        updateGunDropESP()
    end
})

-- ÃÂÃÂ²Ã‘â€šÃÂ¾ÃÂ¼ÃÂ°Ã‘â€šÃÂ¸Ã‘â€¡ÃÂµÃ‘ÂÃÂºÃÂ¾ÃÂµ ÃÂ¾ÃÂ±ÃÂ½ÃÂ¾ÃÂ²ÃÂ»ÃÂµÃÂ½ÃÂ¸ÃÂµ ÃÂ¿Ã‘â‚¬ÃÂ¸ Ã‘ÂÃÂ¼ÃÂµÃÂ½ÃÂµ ÃÂºÃÂ°Ã‘â‚¬Ã‘â€šÃ‘â€¹
workspace.ChildAdded:Connect(function(child)
    if table.find(mapPaths, child.Name) then
        task.wait(2) -- Ãâ€“ÃÂ´ÃÂµÃÂ¼ ÃÂ·ÃÂ°ÃÂ³Ã‘â‚¬Ã‘Æ’ÃÂ·ÃÂºÃ‘Æ’ ÃÂºÃÂ°Ã‘â‚¬Ã‘â€šÃ‘â€¹
        updateGunDropESP()
    end
end)

RunService.RenderStepped:Connect(function()
    UpdateRoles()
    if ESPConfig.HighlightMurderer or ESPConfig.HighlightInnocent or ESPConfig.HighlightSheriff then
        UpdateHighlights()
    end
end)

Players.PlayerRemoving:Connect(function(player)
    if player == LP then
        RemoveAllHighlights()
    end
end)

-- === TELEPORT TAB (FIXED & ENGLISH) ===
local teleportTarget = nil
local Players = game:GetService("Players")
local LocalPlayer = Players.LocalPlayer

-- Get list of players (only those with a character)
local function getPlayerList()
    local playersList = {}
    for _, player in pairs(Players:GetPlayers()) do
        if player ~= LocalPlayer and player.Character then
            table.insert(playersList, player.Name)
        end
    end
    table.sort(playersList) -- Alphabetical order
    return playersList
end

-- Default TP Section
Tabs.TeleportTab:Section({ 
    Title = gradient("Default TP", Color3.fromHex("#00448c"), Color3.fromHex("#0affd6"))
})

-- Dropdown with live update
local teleportDropdown = Tabs.TeleportTab:Dropdown({
    Title = "Players",
    Values = getPlayerList(),
    Value = "Select Player",
    Multi = false,
    Callback = function(selected)
        if selected and selected ~= "Select Player" then
            teleportTarget = Players:FindFirstChild(selected)
   
        else
            teleportTarget = nil
        end
    end
})

-- Teleport to selected player
local function teleportToPlayer()
    if not teleportTarget or not teleportTarget.Character then
        WindUI:Notify({
            Title = "Teleport Failed",
            Content = "Player not found or disconnected!",
            Icon = "x-circle",
            Duration = 3
        })
        return
    end

    local targetRoot = teleportTarget.Character:FindFirstChild("HumanoidRootPart")
    local localRoot = LocalPlayer.Character and LocalPlayer.Character:FindFirstChild("HumanoidRootPart")

    if targetRoot and localRoot then
        localRoot.CFrame = targetRoot.CFrame * CFrame.new(0, 0, -2) -- Teleport behind
        WindUI:Notify({
            Title = "Teleported!",
            Content = "TP to " .. teleportTarget.Name .. " Success",
            Icon = "check-circle",
            Duration = 2
        })
    else
        WindUI:Notify({
            Title = "Error",
            Content = "Failed to teleport (no HumanoidRootPart)",
            Icon = "x-circle",
            Duration = 3
        })
    end
end

Tabs.TeleportTab:Button({
    Title = gradient("Teleport to Player", Color3.fromHex("#00ff88"), Color3.fromHex("#00cc66")),
    Variant = "Primary",
    Icon = "arrow-right",
    Callback = teleportToPlayer
})

Tabs.TeleportTab:Button({
    Title = gradient("Refresh Player List", Color3.fromHex("#ffaa00"), Color3.fromHex("#cc8800")),
    Variant = "Secondary",
    Icon = "refresh-cw",
    Callback = function()
        local newList = getPlayerList()
        teleportDropdown:Refresh(newList)
        WindUI:Notify({
            Title = "List Updated",
            Content = #newList .. " players online",
            Icon = "check-circle",
            Duration = 2
        })
    end
})

-- Auto-refresh every 5 seconds
coroutine.wrap(function()
    while true do
        task.wait(5)
        local newList = getPlayerList()
        if #newList > 0 then
            teleportDropdown:Refresh(newList)
        end
    end
end)()

-- Update when player joins/leaves
Players.PlayerAdded:Connect(function()
    task.wait(1)
    teleportDropdown:Refresh(getPlayerList())
end)

Players.PlayerRemoving:Connect(function()
    task.wait(0.5)
    teleportDropdown:Refresh(getPlayerList())
end)

-- === SPECIAL TP SECTION ===
Tabs.TeleportTab:Section({ 
    Title = gradient("Special TP", Color3.fromHex("#b914fa"), Color3.fromHex("#7023c2"))
})

Tabs.TeleportTab:Button({
    Title = gradient("TP to Sheriff", Color3.fromHex("#001e80"), Color3.fromHex("#16f2d9")),
    Callback = function()
        UpdateRoles()
        if Sheriff then
            local sheriffPlayer = Players:FindFirstChild(Sheriff)
            if sheriffPlayer and sheriffPlayer.Character then
                local targetRoot = sheriffPlayer.Character:FindFirstChild("HumanoidRootPart")
                local localRoot = LocalPlayer.Character and LocalPlayer.Character:FindFirstChild("HumanoidRootPart")
                if targetRoot and localRoot then
                    localRoot.CFrame = targetRoot.CFrame * CFrame.new(0, 0, -2)
                    WindUI:Notify({
                        Title = "TP Sheriff",
                        Content = "Teleported to " .. Sheriff,
                        Icon = "check-circle",
                        Duration = 2
                    })
                    return
                end
            end
        end
        WindUI:Notify({
            Title = "Error",
            Content = "Sheriff not found",
            Icon = "x-circle",
            Duration = 2
        })
    end
})

Tabs.TeleportTab:Button({
    Title = gradient("TP to Murderer", Color3.fromHex("#e80909"), Color3.fromHex("#630404")),
    Callback = function()
        UpdateRoles()
        if Murder then
            local murderPlayer = Players:FindFirstChild(Murder)
            if murderPlayer and murderPlayer.Character then
                local targetRoot = murderPlayer.Character:FindFirstChild("HumanoidRootPart")
                local localRoot = LocalPlayer.Character and LocalPlayer.Character:FindFirstChild("HumanoidRootPart")
                if targetRoot and localRoot then
                    localRoot.CFrame = targetRoot.CFrame * CFrame.new(0, 0, -2)
                    WindUI:Notify({
                        Title = "TP Murderer",
                        Content = "Teleported to " .. Murder,
                        Icon = "check-circle",
                        Duration = 2
                    })
                    return
                end
            end
        end
        WindUI:Notify({
            Title = "Error",
            Content = "Murderer not found",
            Icon = "x-circle",
            Duration = 2
        })
    end
})

-- Aimbot
local roles = {}
local Murder, Sheriff
local isCameraLocked = false
local isSpectating = false
local lockedRole = nil
local cameraConnection = nil
local originalCameraType = Enum.CameraType.Custom
local originalCameraSubject = nil

function IsAlive(player)
    for name, data in pairs(roles) do
        if player.Name == name then
            return not data.Killed and not data.Dead
        end
    end
    return false
end

local function UpdateRoles()
    local success, result = pcall(function()
        return ReplicatedStorage:FindFirstChild("GetPlayerData", true):InvokeServer()
    end)
    if success then
        roles = result or {}
        Murder, Sheriff = nil, nil
        for name, data in pairs(roles) do
            if data.Role == "Murderer" then Murder = name
            elseif data.Role == 'Sheriff' then Sheriff = name end
        end
    end
end

Tabs.AimbotTab:Section({Title = gradient("Default AimBot", Color3.fromHex("#00448c"), Color3.fromHex("#0affd6"))})

RoleDropdown = Tabs.AimbotTab:Dropdown({
    Title = "Target Role",
    Values = {"None", "Sheriff", "Murderer"},
    Value = "None",
    Callback = function(selected)
        lockedRole = (selected ~= "None") and selected or nil
    end
})

Tabs.AimbotTab:Toggle({
    Title = "Spectate Mode",
    Default = false,
    Callback = function(state)
        isSpectating = state
        if state then
            originalCameraType = CurrentCamera.CameraType
            originalCameraSubject = CurrentCamera.CameraSubject
            CurrentCamera.CameraType = Enum.CameraType.Scriptable
        else
            CurrentCamera.CameraType = originalCameraType
            CurrentCamera.CameraSubject = originalCameraSubject
        end
    end
})

Tabs.AimbotTab:Toggle({
    Title = "Lock Camera",
    Default = false,
    Callback = function(state)
        isCameraLocked = state
        if not state and not isSpectating then
            CurrentCamera.CameraType = originalCameraType
            CurrentCamera.CameraSubject = originalCameraSubject
        end
    end
})

local function GetTargetPosition()
    if not lockedRole then return nil end
    local targetName = lockedRole == "Sheriff" and Sheriff or Murder
    if not targetName then return nil end
    local player = Players:FindFirstChild(targetName)
    if not player or not IsAlive(player) then return nil end
    local character = player.Character
    if not character then return nil end
    local head = character:FindFirstChild("Head")
    return head and head.Position or nil
end

local function UpdateSpectate()
    if not isSpectating or not lockedRole then return end
    local targetPos = GetTargetPosition()
    if not targetPos then return end
    local offset = CFrame.new(0, 2, 8)
    local targetChar = Players:FindFirstChild(lockedRole == "Sheriff" and Sheriff or Murder).Character
    if targetChar then
        local root = targetChar:FindFirstChild("HumanoidRootPart")
        if root then
            CurrentCamera.CFrame = root.CFrame * offset
        end
    end
end

local function UpdateLockCamera()
    if not isCameraLocked or not lockedRole then return end
    local targetPos = GetTargetPosition()
    if not targetPos then return end
    local currentPos = CurrentCamera.CFrame.Position
    CurrentCamera.CFrame = CFrame.new(currentPos, targetPos)
end

local function Update()
    if isSpectating then
        UpdateSpectate()
    elseif isCameraLocked then
        UpdateLockCamera()
    end
end

local function AutoUpdate()
    while true do
        UpdateRoles()
        task.wait(3)
    end
end

coroutine.wrap(AutoUpdate)()
cameraConnection = RunService.RenderStepped:Connect(Update)

LocalPlayer.AncestryChanged:Connect(function()
    if not LocalPlayer.Parent and cameraConnection then
        cameraConnection:Disconnect()
        CurrentCamera.CameraType = originalCameraType
        CurrentCamera.CameraSubject = originalCameraSubject
    end
end)

UpdateRoles()

local SilentAim = {
    Enabled = false,
    Prediction = 0.14
}

-- ÃÅ¸ÃÂ¾ÃÂ»Ã‘Æ’Ã‘â€¡ÃÂ°ÃÂµÃÂ¼ Ã‘Æ’ÃÂ±ÃÂ¸ÃÂ¹Ã‘â€ Ã‘Æ’
local function GetMurderer()
    local success, roles = pcall(function()
        return game:GetService("ReplicatedStorage"):FindFirstChild("GetPlayerData", true):InvokeServer()
    end)
    if success and roles then
        for name, data in pairs(roles) do
            if data.Role == "Murderer" then
                return game:GetService("Players"):FindFirstChild(name)
            end
        end
    end
    return nil
end

-- ÃÅ¾Ã‘ÂÃÂ½ÃÂ¾ÃÂ²ÃÂ½ÃÂ¾ÃÂ¹ Ã‘â€¦Ã‘Æ’ÃÂº
local oldNamecall
oldNamecall = hookmetamethod(game, "__namecall", function(self, ...)
    if SilentAim.Enabled and not checkcaller() then
        local method = getnamecallmethod()
        if method == "InvokeServer" and tostring(self) == "HitPart" then
            local murderer = GetMurderer()
            if murderer and murderer.Character then
                local head = murderer.Character:FindFirstChild("Head")
                if head then
                    local root = murderer.Character:FindFirstChild("HumanoidRootPart")
                    local predictedPos = root.Position + (root.Velocity * SilentAim.Prediction)
                    return oldNamecall(self, predictedPos, head)
                end
            end
        end
    end
    return oldNamecall(self, ...)
end)

-- ÃÅ¸Ã‘â‚¬ÃÂ¾Ã‘ÂÃ‘â€šÃÂ¾ Ã‘â€šÃÂ¾ÃÂ³ÃÂ³ÃÂ» ÃÂ² UI
local Toggle = Tabs.AimbotTab:Toggle({
    Title = "Silent Aim",
    Default = false,
    Callback = function(state)
        SilentAim.Enabled = state
    end
})
-- === AUTOFARM TAB (Halloween Event - Candy Collection) ===
Tabs.AutoFarm:Section({ 
    Title = gradient("Candy Collection", Color3.fromHex("#ff8c00"), Color3.fromHex("#ff4500")),
    Icon = "candy" 
})

local AutoFarmConfig = {
    CandyAutofarm = false,
    AutoReset = false,
    AutoFlingMurderer = false,
    Speed = 30
}

--------------------------------------------------------
--  ðŸ”„ NOUVEAU SYSTÃˆME CANDY AUTOFARM (FLY TWEEN)
--------------------------------------------------------

local autofarmActive = false
local flySpeed = 20
local collected = 0
local visitedPositions = {}
local farmThread = nil
local rootPart = nil

local player = LocalPlayer
local character = player.Character or player.CharacterAdded:Wait()
local TweenService = game:GetService("TweenService")
local ReplicatedStorage = game:GetService("ReplicatedStorage")

local Players = game:GetService("Players")
local RunService = game:GetService("RunService")

local collectSound = Instance.new("Sound")
collectSound.SoundId = "rbxassetid://12221967"
collectSound.Volume = 1

player.CharacterAdded:Connect(function(char)
    character = char
    rootPart = char:WaitForChild("HumanoidRootPart")
    collectSound.Parent = rootPart
end)

local function flyTo(pos, speed)
    if not rootPart then return end
    local dist = (pos - rootPart.Position).Magnitude
    local tweenInfo = TweenInfo.new(dist / speed, Enum.EasingStyle.Linear)
    local tween = TweenService:Create(rootPart, tweenInfo, {CFrame = CFrame.new(pos)})
    tween:Play()
    tween.Completed:Wait()
end

function _AutoFarm(active)
    autofarmActive = active
    collected = 0
    visitedPositions = {}

    if not rootPart then 
        rootPart = character:FindFirstChild("HumanoidRootPart") 
    end
    if not rootPart then return end

    collectSound.Parent = rootPart

    if farmThread then task.cancel(farmThread) end

    if autofarmActive then
        farmThread = task.spawn(function()
            while autofarmActive do
                character = player.Character or player.CharacterAdded:Wait()
                rootPart = character:FindFirstChild("HumanoidRootPart")

                if rootPart then
                    local closest, shortest = nil, math.huge

                    for _, obj in ipairs(workspace:GetDescendants()) do
                        if obj:IsA("BasePart") and obj.Name == "Coin_Server" then
                            local dist = (obj.Position - rootPart.Position).Magnitude
                            if dist < shortest and dist < 250 and not visitedPositions[obj] then
                                closest = obj
                                shortest = dist
                            end
                        end
                    end

                    if closest and closest:IsDescendantOf(workspace) then
                        flyTo(closest.Position, flySpeed)
                        visitedPositions[closest] = true
                        collected += 1
                        collectSound:Play()
                    end
                end

                task.wait(0.1)
            end
        end)
    else
        if farmThread then 
            task.cancel(farmThread)
            farmThread = nil 
        end
    end
end

--------------------------------------------------------
--  ðŸ”„ **NOUVEAU AUTO RESET SYSTEM (Ã‰vÃ©nements OFFICIELS)**
--------------------------------------------------------

local autoResetEnabled = false
local resetting = false
local bag_full = false
local start_position = nil

local CoinCollected = ReplicatedStorage.Remotes.Gameplay.CoinCollected
local RoundStart = ReplicatedStorage.Remotes.Gameplay.RoundStart
local RoundEnd = ReplicatedStorage.Remotes.Gameplay.RoundEndFade

local function getCharacter()
    return player.Character or player.CharacterAdded:Wait()
end

local function getHRP()
    return getCharacter():WaitForChild("HumanoidRootPart")
end

CoinCollected.OnClientEvent:Connect(function(_, current, max)
    if current == max and autoResetEnabled and not resetting then
        resetting = true
        bag_full = true

        local hrp = getHRP()

        -- Retour Ã  la position sauvegardÃ©e
        if start_position then
            local tween = TweenService:Create(
                hrp,
                TweenInfo.new(2, Enum.EasingStyle.Linear),
                {CFrame = start_position}
            )
            tween:Play()
            tween.Completed:Wait()
        end

        task.wait(0.5)

        -- RESET PLAYER
        local char = player.Character
        if char and char:FindFirstChild("Humanoid") then
            char.Humanoid.Health = 0
        end
        
        player.CharacterAdded:Wait()

        task.wait(1.5)
        resetting = false
        bag_full = false
    end
end)

RoundStart.OnClientEvent:Connect(function()
    start_position = getHRP().CFrame
end)

RoundEnd.OnClientEvent:Connect(function()
    bag_full = false
    resetting = false
end)

--------------------------------------------------------
--  AUTO FLING MURDERER
--------------------------------------------------------

local function flingMurderer()
    if not AutoFarmConfig.AutoFlingMurderer then return end
    
    local playerData = ReplicatedStorage:FindFirstChild("GetPlayerData", true):InvokeServer()
    local candyCount = playerData[LocalPlayer.Name].Candy or 0
    local maxCandy = 100
    
    if candyCount >= maxCandy then
        UpdateRoles()
        if Murder then
            local murderer = Players:FindFirstChild(Murder)
            if murderer and murderer.Character then
                local murdererHRP = murderer.Character:FindFirstChild("HumanoidRootPart")
                if murdererHRP then
                    local bv = Instance.new("BodyVelocity")
                    bv.Velocity = Vector3.new(0, 10000, 0)
                    bv.MaxForce = Vector3.new(40000, 40000, 40000)
                    bv.Parent = murdererHRP
                    task.wait(0.5)
                    bv:Destroy()
                end
            end
        end
    end
end

--------------------------------------------------------
--  UI TOGGLES
--------------------------------------------------------

-- Candy Autofarm
Tabs.AutoFarm:Toggle({
    Title = gradient("Candy Autofarm", Color3.fromHex("#ff8c00"), Color3.fromHex("#ff4500")),
    Default = false,
    Desc = "Automatically collect Halloween candy for event rewards",
    Callback = function(state)
        AutoFarmConfig.CandyAutofarm = state
        _AutoFarm(state)
    end
})

-- Auto Reset (nouveau systÃ¨me)
Tabs.AutoFarm:Toggle({
    Title = gradient("Auto Reset Character", Color3.fromHex("#00bfff"), Color3.fromHex("#1e90ff")),
    Default = false,
    Desc = "Reset when bag is full + return to start position",
    Callback = function(state)
        AutoFarmConfig.AutoReset = state
        autoResetEnabled = state
    end
})

-- Auto Fling Murderer
Tabs.AutoFarm:Toggle({
    Title = gradient("Auto Fling Murderer", Color3.fromHex("#ff4500"), Color3.fromHex("#dc143c")),
    Default = false,
    Desc = "Automatically fling murderer when bag is full",
    Callback = function(state)
        AutoFarmConfig.AutoFlingMurderer = state
        if state then
            coroutine.wrap(function()
                while AutoFarmConfig.AutoFlingMurderer do
                    flingMurderer()
                    task.wait(1)
                end
            end)()
        end
    end
})

-- Autofarm Speed Slider
Tabs.AutoFarm:Slider({
    Title = gradient("Autofarm Speed", Color3.fromHex("#00ff7f"), Color3.fromHex("#32cd32")),
    Value = { Min = 10, Max = 100, Default = 30 },
    Desc = "Adjust collection speed",
    Callback = function(value)
        AutoFarmConfig.Speed = value
        flySpeed = value
    end
})

--------------------------------------------------------
--  HEARTBEAT SPEED (WalkSpeed Sync)
--------------------------------------------------------

RunService.Heartbeat:Connect(function()
    if AutoFarmConfig.CandyAutofarm and LocalPlayer.Character then
        LocalPlayer.Character.Humanoid.WalkSpeed = AutoFarmConfig.Speed
    else
        if LocalPlayer.Character then
            LocalPlayer.Character.Humanoid.WalkSpeed = 16
        end
    end
end)
-- ========================================
-- === INNOCENT TAB + FONCTIONS (tout ensemble) ===
-- ========================================
do
	-- === FONCTIONS INNOCENT (placÃ©es juste avant le Tab) ===
	local gunDropESPEnabled = true
	local notifiedGunDrops = {}
	local mapGunDrops = {
		"ResearchFacility", "Hospital3", "MilBase", "House2", "Workplace",
		"Mansion2", "BioLab", "Hotel", "Factory", "Bank2", "PoliceStation"
	}

	local GunSystem = {
		AutoGrabEnabled = false,
		NotifyGunDrop = true,
		GunDropCheckInterval = 1,
		ActiveGunDrops = {},
		GunDropHighlights = {}
	}

	-- Scanner les GunDrops
	local function ScanForGunDrops()
		GunSystem.ActiveGunDrops = {}
		for _, mapName in ipairs(mapGunDrops) do
			local map = workspace:FindFirstChild(mapName)
			if map and map:FindFirstChild("GunDrop") then
				table.insert(GunSystem.ActiveGunDrops, map.GunDrop)
			end
		end
		local rootGunDrop = workspace:FindFirstChild("GunDrop")
		if rootGunDrop then table.insert(GunSystem.ActiveGunDrops, rootGunDrop) end
	end

	-- Prendre le pistolet
	local function GrabGun(gunDrop)
		if not gunDrop then
			ScanForGunDrops()
			if #GunSystem.ActiveGunDrops == 0 then
				WindUI:Notify({Title = "Gun System", Content = "Aucun pistolet sur la carte", Icon = "x-circle", Duration = 3})
				return false
			end
			local nearest, dist = nil, math.huge
			local root = LocalPlayer.Character and LocalPlayer.Character:FindFirstChild("HumanoidRootPart")
			if root then
				for _, drop in ipairs(GunSystem.ActiveGunDrops) do
					local d = (root.Position - drop.Position).Magnitude
					if d < dist then nearest, dist = drop, d end
				end
			end
			gunDrop = nearest
		end

		if gunDrop and LocalPlayer.Character then
			local root = LocalPlayer.Character:FindFirstChild("HumanoidRootPart")
			if root then
				root.CFrame = gunDrop.CFrame
				task.wait(0.3)
				local prompt = gunDrop:FindFirstChildOfClass("ProximityPrompt")
				if prompt then
					fireproximityprompt(prompt)
					WindUI:Notify({Title = "Gun System", Content = "Pistolet pris !", Icon = "check-circle", Duration = 3})
					return true
				end
			end
		end
		return false
	end

	-- Auto Grab
	local function AutoGrabGun()
		while GunSystem.AutoGrabEnabled do
			ScanForGunDrops()
			if #GunSystem.ActiveGunDrops > 0 and LocalPlayer.Character then
				local root = LocalPlayer.Character:FindFirstChild("HumanoidRootPart")
				if root then
					local nearest, dist = nil, math.huge
					for _, drop in ipairs(GunSystem.ActiveGunDrops) do
						local d = (root.Position - drop.Position).Magnitude
						if d < dist then nearest, dist = drop, d end
					end
					if nearest then
						root.CFrame = nearest.CFrame
						task.wait(0.3)
						local prompt = nearest:FindFirstChildOfClass("ProximityPrompt")
						if prompt then fireproximityprompt(prompt) end
					end
				end
			end
			task.wait(GunSystem.GunDropCheckInterval)
		end
	end

	-- Prendre + Tirer sur le Murderer
	local function GrabAndShootMurderer()
		if LocalPlayer.Character and LocalPlayer.Character:FindFirstChild("Gun") then else
			if not GrabGun() then
				WindUI:Notify({Title = "Gun System", Content = "Ã‰chec prise de pistolet", Icon = "x-circle", Duration = 3})
				return
			end
			task.wait(0.1)
		end

		local gun = LocalPlayer.Backpack:FindFirstChild("Gun")
		if gun then gun.Parent = LocalPlayer.Character end
		gun = LocalPlayer.Character:FindFirstChild("Gun")
		if not gun then
			WindUI:Notify({Title = "Gun System", Content = "Pistolet non Ã©quipÃ©", Icon = "x-circle", Duration = 3})
			return
		end

		local roles = ReplicatedStorage:FindFirstChild("GetPlayerData", true):InvokeServer()
		local murdererName
		for name, data in pairs(roles) do
			if data.Role == "Murderer" then murdererName = name; break end
		end
		if not murdererName then
			WindUI:Notify({Title = "Gun System", Content = "Murderer non trouvÃ©", Icon = "x-circle", Duration = 3})
			return
		end

		local murderer = Players:FindFirstChild(murdererName)
		if not murderer or not murderer.Character then return end

		local targetRoot = murderer.Character:FindFirstChild("HumanoidRootPart")
		local localRoot = LocalPlayer.Character:FindFirstChild("HumanoidRootPart")
		if targetRoot and localRoot then
			localRoot.CFrame = targetRoot.CFrame * CFrame.new(0, 0, -4)
			task.wait(0.1)
		end

		if gun:FindFirstChild("KnifeLocal") and gun.KnifeLocal:FindFirstChild("CreateBeam") then
			local args = {10, targetRoot.Position, "AH2"}
			gun.KnifeLocal.CreateBeam.RemoteFunction:InvokeServer(unpack(args))
			WindUI:Notify({Title = "Gun System", Content = "Tir sur le Murderer !", Icon = "check-circle", Duration = 3})
		end
	end

	-- Notification GunDrop
	local function checkForGunDrops()
		for _, mapName in ipairs(mapGunDrops) do
			local map = workspace:FindFirstChild(mapName)
			if map then
				local gunDrop = map:FindFirstChild("GunDrop")
				if gunDrop and not notifiedGunDrops[gunDrop] then
					if gunDropESPEnabled then
						WindUI:Notify({Title = "GunDrop", Content = "Pistolet sur : " .. mapName, Icon = "alert-circle", Duration = 5})
					end
					notifiedGunDrops[gunDrop] = true
				end
			end
		end
	end

	-- Suivi des GunDrops
	for _, mapName in ipairs(mapGunDrops) do
		local map = workspace:FindFirstChild(mapName)
		if map then
			map.ChildAdded:Connect(function(child)
				if child.Name == "GunDrop" then
					task.wait(0.5)
					checkForGunDrops()
				end
			end)
			map.ChildRemoved:Connect(function(child)
				if child.Name == "GunDrop" and notifiedGunDrops[child] then
					notifiedGunDrops[child] = nil
				end
			end)
		end
	end
	workspace.ChildAdded:Connect(function(child)
		if table.find(mapGunDrops, child.Name) then
			task.wait(2)
			checkForGunDrops()
		end
	end)

	-- === ONGLETS INNOCENT (aprÃ¨s les fonctions) ===
	Tabs.InnocentTab:Toggle({
		Title = "Notify GunDrop",
		Default = true,
		Callback = function(state)
			gunDropESPEnabled = state
			if state then task.spawn(checkForGunDrops) end
		end
	})

	Tabs.InnocentTab:Button({ Title = "Grab Gun", Callback = GrabGun })

	Tabs.InnocentTab:Toggle({
		Title = "Auto Grab Gun",
		Default = false,
		Callback = function(state)
			GunSystem.AutoGrabEnabled = state
			if state then coroutine.wrap(AutoGrabGun)() end
		end
	})

	Tabs.InnocentTab:Button({ Title = "Grab Gun & Shoot Murderer", Callback = GrabAndShootMurderer })

	-- Init
	task.spawn(function()
		if not LocalPlayer.Character then LocalPlayer.CharacterAdded:Wait() end
		ScanForGunDrops()
		if GunSystem.AutoGrabEnabled then coroutine.wrap(AutoGrabGun)() end
	end)
end

-- ========================================
-- === MURDER TAB + FONCTIONS (tout ensemble) ===
-- ========================================
do
	-- === FONCTIONS MURDER ===
	local killActive = false
	local attackDelay = 0.5
	local targetRoles = {"Sheriff", "Hero", "Innocent"}

	local function equipKnife()
		local char = LocalPlayer.Character
		if not char then return false end
		if char:FindFirstChild("Knife") then return true end
		local knife = LocalPlayer.Backpack:FindFirstChild("Knife")
		if knife then knife.Parent = char; return true end
		return false
	end

	local function getNearestTarget()
		local targets = {}
		local localRoot = LocalPlayer.Character and LocalPlayer.Character:FindFirstChild("HumanoidRootPart")
		if not localRoot then return nil end

		local roles = ReplicatedStorage:FindFirstChild("GetPlayerData", true):InvokeServer()
		for _, player in ipairs(Players:GetPlayers()) do
			if player ~= LocalPlayer and player.Character then
				local role = roles[player.Name] and roles[player.Name].Role
				local hrp = player.Character:FindFirstChild("HumanoidRootPart")
				local hum = player.Character:FindFirstChild("Humanoid")
				if role and hum and hum.Health > 0 and hrp and table.find(targetRoles, role) then
					table.insert(targets, {Player = player, Distance = (localRoot.Position - hrp.Position).Magnitude})
				end
			end
		end
		table.sort(targets, function(a, b) return a.Distance < b.Distance end)
		return targets[1] and targets[1].Player
	end

	local function attackTarget(target)
		if not target or not target.Character then return false end
		local hum = target.Character:FindFirstChild("Humanoid")
		if not hum or hum.Health <= 0 then return false end

		if not equipKnife() then
			WindUI:Notify({Title = "Kill", Content = "Pas de couteau", Icon = "x-circle", Duration = 2})
			return false
		end

		local targetRoot = target.Character:FindFirstChild("HumanoidRootPart")
		local localRoot = LocalPlayer.Character:FindFirstChild("HumanoidRootPart")
		if targetRoot and localRoot then
			localRoot.CFrame = CFrame.new(targetRoot.Position + (localRoot.Position - targetRoot.Position).Unit * 2, targetRoot.Position)
		end

		local knife = LocalPlayer.Character:FindFirstChild("Knife")
		if knife and knife:FindFirstChild("Stab") then
			for i = 1, 3 do knife.Stab:FireServer("Down") end
			return true
		end
		return false
	end

	local function killTargets()
		if killActive then return end
		killActive = true
		WindUI:Notify({Title = "Kill", Content = "Attaque lancÃ©e...", Icon = "alert-circle", Duration = 2})

		task.spawn(function()
			while killActive do
				local target = getNearestTarget()
				if not target then
					WindUI:Notify({Title = "Kill", Content = "Aucune cible", Icon = "check-circle", Duration = 2})
					killActive = false
					break
				end
				if attackTarget(target) then
					WindUI:Notify({Title = "Kill", Content = "Attaque sur " .. target.Name, Icon = "check-circle", Duration = 1})
				end
				task.wait(attackDelay)
			end
		end)
	end

	local function stopKilling()
		killActive = false
		WindUI:Notify({Title = "Kill", Content = "Attaque arrÃªtÃ©e", Icon = "x-circle", Duration = 2})
	end

	-- === ONGLETS MURDER ===
	Tabs.MurderTab:Section({ Title = gradient("Kill Functions", Color3.fromHex("#e80909"), Color3.fromHex("#630404")) })

	Tabs.MurderTab:Toggle({
		Title = "Kill All",
		Default = false,
		Callback = function(state)
			if state then killTargets() else stopKilling() end
		end
	})

	Tabs.MurderTab:Slider({
		Title = "Attack Delay",
		Step = 0.1,
		Value = {Min = 0.1, Max = 2, Default = 0.5},
		Callback = function(value)
			attackDelay = value
			WindUI:Notify({Title = "Kill Targets", Content = "Delay: " .. value .. "s", Icon = "check-circle", Duration = 2})
		end
	})

	Tabs.MurderTab:Button({
		Title = "Equip Knife",
		Callback = function()
			if equipKnife() then
				WindUI:Notify({Title = "Knife", Content = "Ã‰quipÃ© !", Icon = "check-circle", Duration = 2})
			else
				WindUI:Notify({Title = "Knife", Content = "Introuvable", Icon = "x-circle", Duration = 2})
			end
		end
	})
end

-- ========================================
-- === SHERIFF TAB + FONCTIONS (tout ensemble) ===
-- ========================================
do
	-- === FONCTIONS SHERIFF ===
	local shotType = "Default"
	local shotButton = nil
	local shotButtonFrame = nil
	local shotButtonActive = false
	local buttonSize = 50
	local isDragging = false

	local function ShootMurderer()
		if not LocalPlayer.Character or LocalPlayer.Character:FindFirstChild("Humanoid").Health <= 0 then return end

		local roles = ReplicatedStorage:FindFirstChild("GetPlayerData", true):InvokeServer()
		local murdererName
		for name, data in pairs(roles) do
			if data.Role == "Murderer" then murdererName = name; break end
		end
		if not murdererName then return end

		local murderer = Players:FindFirstChild(murdererName)
		if not murderer or not murderer.Character or murderer.Character:FindFirstChild("Humanoid").Health <= 0 then return end

		local gun = LocalPlayer.Character:FindFirstChild("Gun") or LocalPlayer.Backpack:FindFirstChild("Gun")
		if shotType == "Default" and not gun then return end
		if gun and not LocalPlayer.Character:FindFirstChild("Gun") then gun.Parent = LocalPlayer.Character end

		if shotType == "Teleport" then
			local tRoot = murderer.Character:FindFirstChild("HumanoidRootPart")
			local lRoot = LocalPlayer.Character:FindFirstChild("HumanoidRootPart")
			if tRoot and lRoot then lRoot.CFrame = tRoot.CFrame * CFrame.new(0, 0, -4) end
		end

		gun = LocalPlayer.Character:FindFirstChild("Gun")
		if gun and gun:FindFirstChild("KnifeLocal") and gun.KnifeLocal:FindFirstChild("CreateBeam") then
			local target = murderer.Character:FindFirstChild("HumanoidRootPart")
			if target then
				gun.KnifeLocal.CreateBeam.RemoteFunction:InvokeServer(1, target.Position, "AH2")
			end
		end
	end

	local function CreateShotButton()
		if shotButton then return end

		local screenGui = Instance.new("ScreenGui")
		screenGui.Name = "WindUI_SheriffGui"
		screenGui.Parent = game:GetService("CoreGui")
		screenGui.ResetOnSpawn = false
		screenGui.DisplayOrder = 999

		shotButtonFrame = Instance.new("Frame")
		shotButtonFrame.Size = UDim2.new(0, buttonSize, 0, buttonSize)
		shotButtonFrame.Position = UDim2.new(1, -buttonSize - 20, 0.5, -buttonSize / 2)
		shotButtonFrame.AnchorPoint = Vector2.new(1, 0.5)
		shotButtonFrame.BackgroundTransparency = 1
		shotButtonFrame.ZIndex = 100
		shotButtonFrame.Parent = screenGui

		shotButton = Instance.new("TextButton")
		shotButton.Size = UDim2.new(1, 0, 1, 0)
		shotButton.BackgroundColor3 = Color3.fromRGB(120, 120, 120)
		shotButton.BackgroundTransparency = 0.5
		shotButton.Text = "SHOT"
		shotButton.TextColor3 = Color3.fromRGB(255, 255, 255)
		shotButton.TextScaled = true
		shotButton.Font = Enum.Font.GothamBold
		shotButton.ZIndex = 101
		shotButton.Parent = shotButtonFrame

		local stroke = Instance.new("UIStroke", shotButton)
		stroke.Color = Color3.fromRGB(0, 40, 150)
		stroke.Thickness = 2

		local corner = Instance.new("UICorner", shotButton)
		corner.CornerRadius = UDim.new(0.3, 0)

		local shadow = Instance.new("ImageLabel", shotButton)
		shadow.Size = UDim2.new(1, 10, 1, 10)
		shadow.Position = UDim2.new(0.5, 0, 0.5, 0)
		shadow.AnchorPoint = Vector2.new(0.5, 0.5)
		shadow.BackgroundTransparency = 1
		shadow.Image = "rbxassetid://1316045217"
		shadow.ImageColor3 = Color3.new(0,0,0)
		shadow.ImageTransparency = 0.85
		shadow.ScaleType = Enum.ScaleType.Slice
		shadow.SliceCenter = Rect.new(10,10,118,118)
		shadow.ZIndex = 100

		local function animatePress()
			local tween = game:GetService("TweenService")
			tween:Create(shotButton, TweenInfo.new(0.1), {Size = UDim2.new(0.9,0,0.9,0), BackgroundColor3 = Color3.fromRGB(70,70,70)}):Play()
			task.wait(0.1)
			tween:Create(shotButton, TweenInfo.new(0.2, Enum.EasingStyle.Elastic), {Size = UDim2.new(1,0,1,0), BackgroundColor3 = Color3.fromRGB(100,100,100)}):Play()
		end

		shotButton.MouseButton1Click:Connect(function()
			animatePress()
			ShootMurderer()
		end)

		-- Drag
		local dragStart, startPos
		shotButton.InputBegan:Connect(function(input)
			if input.UserInputType == Enum.UserInputType.MouseButton1 then
				isDragging = true
				dragStart = input.Position
				startPos = shotButtonFrame.Position
			end
		end)
		shotButton.InputChanged:Connect(function(input)
			if isDragging and input.UserInputType == Enum.UserInputType.MouseMovement then
				local delta = input.Position - dragStart
				shotButtonFrame.Position = UDim2.new(startPos.X.Scale, startPos.X.Offset + delta.X, startPos.Y.Scale, startPos.Y.Offset + delta.Y)
			end
		end)
		shotButton.InputEnded:Connect(function(input)
			if input.UserInputType == Enum.UserInputType.MouseButton1 then isDragging = false end
		end)

		shotButtonActive = true
		WindUI:Notify({Title = "Sheriff", Content = "Bouton de tir activÃ©", Icon = "check-circle", Duration = 3})
	end

	local function RemoveShotButton()
		if not shotButton then return end
		if shotButtonFrame then shotButtonFrame:Destroy() end
		if game:GetService("CoreGui"):FindFirstChild("WindUI_SheriffGui") then
			game:GetService("CoreGui").WindUI_SheriffGui:Destroy()
		end
		shotButton, shotButtonFrame = nil, nil
		shotButtonActive = false
		WindUI:Notify({Title = "Sheriff", Content = "Bouton dÃ©sactivÃ©", Icon = "x-circle", Duration = 3})
	end

	-- === ONGLETS SHERIFF ===
	Tabs.SheriffTab:Section({ Title = gradient("Shot functions", Color3.fromHex("#001e80"), Color3.fromHex("#16f2d9")) })

	Tabs.SheriffTab:Dropdown({
		Title = "Shot Type",
		Values = {"Default", "Teleport"},
		Value = "Default",
		Callback = function(selectedType)
			shotType = selectedType
			WindUI:Notify({Title = "Sheriff System", Content = "Type: " .. selectedType, Icon = "check-circle", Duration = 3})
		end
	})

	Tabs.SheriffTab:Button({ Title = "Shoot murderer", Callback = ShootMurderer })

	Tabs.SheriffTab:Section({ Title = gradient("Shot Button", Color3.fromHex("#001e80"), Color3.fromHex("#16f2d9")) })

	Tabs.SheriffTab:Button({
		Title = "Toggle Shot Button",
		Callback = function()
			if shotButtonActive then RemoveShotButton() else CreateShotButton() end
		end
	})

	Tabs.SheriffTab:Slider({
		Title = "Button Size",
		Step = 1,
		Value = {Min = 10, Max = 100, Default = 50},
		Callback = function(size)
			buttonSize = size
			if shotButtonActive then
				local currentPos = shotButtonFrame.Position
				RemoveShotButton()
				CreateShotButton()
				if shotButtonFrame then shotButtonFrame.Position = currentPos end
			end
			WindUI:Notify({Title = "Sheriff System", Content = "Taille: " .. size, Icon = "check-circle", Duration = 3})
		end
	})
end
-- Settings
local Settings = {
    Hitbox = {
        Enabled = false,
        Size = 5,
        Color = Color3.new(1,0,0),
        Adornments = {},
        Connections = {}
    },
    Noclip = {
        Enabled = false,
        Connection = nil
    },
    AntiAFK = {
        Enabled = false,
        Connection = nil
    }
}

local function ToggleNoclip(state)
        if state then
            Settings.Noclip.Connection = RunService.Stepped:Connect(function()
                local chr = LocalPlayer.Character
                if chr then
                    for _, part in pairs(chr:GetDescendants()) do
                        if part:IsA("BasePart") then
                            part.CanCollide = false
                        end
                    end
                end
                end)
        else
            if Settings.Noclip.Connection then
                Settings.Noclip.Connection:Disconnect()
            end
        end
end

local function UpdateHitboxes()
        for _, plr in pairs(Players:GetPlayers()) do
            if plr ~= LocalPlayer then
                local chr = plr.Character
                local box = Settings.Hitbox.Adornments[plr]
                
                if chr and Settings.Hitbox.Enabled then
                    local root = chr:FindFirstChild("HumanoidRootPart")
                    if root then
                        if not box then
                            box = Instance.new("BoxHandleAdornment")
                            box.Adornee = root
                            box.Size = Vector3.new(Settings.Hitbox.Size, Settings.Hitbox.Size, Settings.Hitbox.Size)
                            box.Color3 = Settings.Hitbox.Color
                            box.Transparency = 0.4
                            box.ZIndex = 10
                            box.Parent = root
                            Settings.Hitbox.Adornments[plr] = box
                        else
                            box.Size = Vector3.new(Settings.Hitbox.Size, Settings.Hitbox.Size, Settings.Hitbox.Size)
                            box.Color3 = Settings.Hitbox.Color
                        end
                    end
                elseif box then
                    box:Destroy()
                    Settings.Hitbox.Adornments[plr] = nil
                end
            end
        end
end

local function ToggleAntiAFK(state)
        if state then
            Settings.AntiAFK.Connection = RunService.Heartbeat:Connect(function()
                pcall(function()
                    local vu = game:GetService("VirtualUser")
                    vu:CaptureController()
                    vu:ClickButton2(Vector2.new())
                end)
            end)
        else
            if Settings.AntiAFK.Connection then
                Settings.AntiAFK.Connection:Disconnect()
            end
        end
end

Tabs.SettingsTab:Section({
    Title = gradient("Hitboxes", Color3.fromHex("#ff0000"), Color3.fromHex("#ff8800"))
})

Tabs.SettingsTab:Toggle({
    Title = "Hixboxes",
    Callback = function(state)
        Settings.Hitbox.Enabled = state
        if state then
            RunService.Heartbeat:Connect(UpdateHitboxes)
        else
            for _, box in pairs(Settings.Hitbox.Adornments) do
                box:Destroy()
            end
            Settings.Hitbox.Adornments = {}
        end
    end
})

Tabs.SettingsTab:Slider({
    Title = "Hitbox size",
    Value = {Min=1, Max=10, Default=5},
    Callback = function(val)
        Settings.Hitbox.Size = val
        UpdateHitboxes()
    end
})

Tabs.SettingsTab:Colorpicker({
    Title = "Hitbox color",
    Default = Color3.new(1,0,0),
    Callback = function(col)
        Settings.Hitbox.Color = col
        UpdateHitboxes()
    end
})

Tabs.SettingsTab:Section({
    Title = gradient("Character Functions", Color3.fromHex("#00eaff"), Color3.fromHex("#002a2e"))
})


Tabs.SettingsTab:Toggle({
    Title = "Anti-AFK",
    Callback = function(state)
        Settings.AntiAFK.Enabled = state
        ToggleAntiAFK(state)
    end
})

Tabs.SettingsTab:Toggle({
    Title = "NoClip",
    Callback = function(state)
        Settings.Noclip.Enabled = state
        ToggleNoclip(state)
    end
})

-- Auto Exec

Tabs.SettingsTab:Section({
    Title = gradient("Auto Execute", Color3.fromHex("#00ff40"), Color3.fromHex("#88f2a2"))
})

local AutoInject = {
    Enabled = false,
    ScriptURL = "https://raw.githubusercontent.com/Snowt-Team/SNT-HUB/refs/heads/main/MM2.txt"
}

Tabs.SettingsTab:Toggle({
    Title = "Auto Inject on Rejoin/Hop",
    Default = false,
    Callback = function(state)
        AutoInject.Enabled = state
        if state then
            SetupAutoInject()
            WindUI:Notify({
                Title = "Auto Inject",
                Content = "script cant inject please reload your game",
                Duration = 3
            })
        else
            WindUI:Notify({
                Title = "Auto Inject",
                Content = "Injected succesfully",
                Duration = 3
            })
        end
    end
})

local function SetupAutoInject()
    if not AutoInject.Enabled then return end
    
    local TeleportService = game:GetService("TeleportService")
    local Players = game:GetService("Players")
    local LocalPlayer = Players.LocalPlayer

    spawn(function()
        wait(2)
        if AutoInject.Enabled then
            pcall(function()
                loadstring(game:HttpGet(AutoInject.ScriptURL))()
            end)
        end
    end)

    LocalPlayer.OnTeleport:Connect(function(state)
        if state == Enum.TeleportState.Started and AutoInject.Enabled then
            queue_on_teleport([[
                wait(2)
                loadstring(game:HttpGet("]]..AutoInject.ScriptURL..[["))()
            ]])
        end
    end)

    game:GetService("Players").PlayerRemoving:Connect(function(player)
        if player == LocalPlayer and AutoInject.Enabled then
            queue_on_teleport([[
                wait(2)
                loadstring(game:HttpGet("]]..AutoInject.ScriptURL..[["))()
            ]])
        end
    end)
end

Tabs.SettingsTab:Button({
    Title = "Manual Re-Inject",
    Callback = function()
        pcall(function()
            loadstring(game:HttpGet(AutoInject.ScriptURL))()
            WindUI:Notify({
                Title = "Manual Inject",
                Content = "Injected succesfully!",
                Duration = 3
            })
        end)
    end
})

-- Socials
Tabs.SocialsTab:Paragraph({
    Title = gradient("Kxrma", Color3.fromHex("#001e80"), Color3.fromHex("#16f2d9")),
    Desc = "My discord channel",
    Image = "bird",
    Color = "White",
    Buttons = {
        { Icon = "circle",
          Title = "my discord",
          Callback = function()
              SetClipboard("https://discord.gg/j6rPU57tBk") end,
        }
    }
})

Tabs.SocialsTab:Paragraph({
    Title = gradient("discord acc", Color3.fromHex("#ffffff"), Color3.fromHex("#363636")),
    Desc = "My discord acc",
    Image = "bird",
    Color = "White",
    Buttons = {
        {
            Title = "discord acc",
            Icon = "circle",
            Callback = function() SetClipboard("koro0080")
    end,
        }
    }
})

-- Changelogs
Tabs.ChangelogsTab:Code({
    Title = "Changelogs:",
    Code = [[
    Early release [Beta]:
    Ã¢â‚¬Â¢ Script has been released
    Ã¢â‚¬Â¢ Shoot murder function
    Ã¢â‚¬Â¢ Silent aimbot
    Ã¢â‚¬Â¢ Special aimbot
    Ã¢â‚¬Â¢ Kill neariest player
    Ã¢â‚¬Â¢ TP to murder/sheriff function
    Ã¢â‚¬Â¢ Esp all: murderer, sheriff, innocent
   More functions will be added in future!
]]
})

Tabs.ChangelogsTab:Code({
    Title = "Next update:",
    Code = [[ The next update is Alpha [0.1.1]
    In future we will be add:
    Ã¢â‚¬Â¢ Autofarm coins function
    Ã¢â‚¬Â¢ Autofarm coins variables
    Ã¢â‚¬Â¢ Kill all function
    Ã¢â‚¬Â¢ TP to Lobby
    Ã¢â‚¬Â¢ Kill sheriff function
    Ã¢â‚¬Â¢ Fix bugs
   The date of update: 17.11.2025!
]]
})

-- Server
local TeleportService = game:GetService("TeleportService")
local HttpService = game:GetService("HttpService")
local Players = game:GetService("Players")

Tabs.ServerTab:Button({
    Title = "Rejoin",
    Callback = function()
        local success, error = pcall(function()
            TeleportService:TeleportToPlaceInstance(game.PlaceId, game.JobId, Players.LocalPlayer)
        end)
        if not success then
            warn("Rejoin error:", error)
        end
    end
})

Tabs.ServerTab:Section({
    Title = ""
})

Tabs.ServerTab:Button({
    Title = "Server Hop",
    Callback = function()
        local placeId = game.PlaceId
        local currentJobId = game.JobId
        
        local function serverHop()
            local servers = {}
            local success, result = pcall(function()
                return HttpService:JSONDecode(HttpService:GetAsync("https://games.roblox.com/v1/games/"..placeId.."/servers/Public?sortOrder=Asc&limit=100"))
            end)
            
            if success and result and result.data then
                for _, server in ipairs(result.data) do
                    if server.id ~= currentJobId then
                        table.insert(servers, server)
                    end
                end
                
                if #servers > 0 then
                    TeleportService:TeleportToPlaceInstance(placeId, servers[math.random(#servers)].id)
                else
                    TeleportService:Teleport(placeId)
                end
            else
                TeleportService:Teleport(placeId)
            end
        end
        
        pcall(serverHop)
    end
})

Tabs.ServerTab:Button({
    Title = "Join to Lower Server",
    Callback = function()
        local placeId = game.PlaceId
        local currentJobId = game.JobId
        
        local function joinLowerServer()
            local servers = {}
            local success, result = pcall(function()
                return HttpService:JSONDecode(HttpService:GetAsync("https://games.roblox.com/v1/games/"..placeId.."/servers/Public?sortOrder=Asc&limit=100"))
            end)
            
            if success and result and result.data then
                for _, server in ipairs(result.data) do
                    if server.id ~= currentJobId and server.playing < (server.maxPlayers or 30) then
                        table.insert(servers, server)
                    end
                end
                
                table.sort(servers, function(a, b)
                    return a.playing < b.playing
                end)
                
                if #servers > 0 then
                    TeleportService:TeleportToPlaceInstance(placeId, servers[1].id)
                else
                    TeleportService:Teleport(placeId)
                end
            else
                TeleportService:Teleport(placeId)
            end
        end
        
        pcall(joinLowerServer)
    end
})

-- Configuration
local HttpService = game:GetService("HttpService")

local folderPath = "WindUI"
makefolder(folderPath)

local function SaveFile(fileName, data)
    local filePath = folderPath .. "/" .. fileName .. ".json"
    local jsonData = HttpService:JSONEncode(data)
    writefile(filePath, jsonData)
end

local function LoadFile(fileName)
    local filePath = folderPath .. "/" .. fileName .. ".json"
    if isfile(filePath) then
        local jsonData = readfile(filePath)
        return HttpService:JSONDecode(jsonData)
    end
end

local function ListFiles()
    local files = {}
    for _, file in ipairs(listfiles(folderPath)) do
        local fileName = file:match("([^/]+)%.json$")
        if fileName then
            table.insert(files, fileName)
        end
    end
    return files
end

Tabs.WindowTab:Section({ Title = "Window" })
local themeValues = {}
for name, _ in pairs(WindUI:GetThemes()) do
    table.insert(themeValues, name)
end

local themeDropdown = Tabs.WindowTab:Dropdown({
    Title = "Select Theme",
    Multi = false,
    AllowNone = false,
    Value = nil,
    Values = themeValues,
    Callback = function(theme)
        WindUI:SetTheme(theme)
    end
})

themeDropdown:Select(WindUI:GetCurrentTheme())

local ToggleTransparency = Tabs.WindowTab:Toggle({
    Title = "Toggle Window Transparency",
    Callback = function(e)
        Window:ToggleTransparency(e)
    end,
    Value = WindUI:GetTransparency()
})

Tabs.WindowTab:Section({ Title = "Save" })

local fileNameInput = ""
Tabs.WindowTab:Input({
    Title = "Write File Name",
    PlaceholderText = "Enter file name",
    Callback = function(text)
        fileNameInput = text
    end
})

Tabs.WindowTab:Button({
    Title = "Save File",
    Callback = function()
        if fileNameInput ~= "" then
            SaveFile(fileNameInput, { Transparent = WindUI:GetTransparency(), Theme = WindUI:GetCurrentTheme() })
        end
    end
})

Tabs.WindowTab:Section({ Title = "Load" })

local filesDropdown
local files = ListFiles()

filesDropdown = Tabs.WindowTab:Dropdown({
    Title = "Select File",
    Multi = false,
    AllowNone = true,
    Values = files,
    Callback = function(selectedFile)
        fileNameInput = selectedFile
    end
})

Tabs.WindowTab:Button({
    Title = "Load File",
    Callback = function()
        if fileNameInput ~= "" then
            local data = LoadFile(fileNameInput)
            if data then
                WindUI:Notify({
                    Title = "File Loaded",
                    Content = "Loaded data: " .. HttpService:JSONEncode(data),
                Duration = 5,
                })
                if data.Transparent then 
                    Window:ToggleTransparency(data.Transparent)
                    ToggleTransparency:SetValue(data.Transparent)
                end
                if data.Theme then WindUI:SetTheme(data.Theme) end
            end
        end
    end
})

Tabs.WindowTab:Button({
    Title = "Overwrite File",
    Callback = function()
        if fileNameInput ~= "" then
            SaveFile(fileNameInput, { Transparent = WindUI:GetTransparency(), Theme = WindUI:GetCurrentTheme() })
        end
    end
})

Tabs.WindowTab:Button({
    Title = "Refresh List",
    Callback = function()
        filesDropdown:Refresh(ListFiles())
    end
})

-- Themes
local currentThemeName = WindUI:GetCurrentTheme()
local themes = WindUI:GetThemes()

local ThemeAccent = themes[currentThemeName].Accent
local ThemeOutline = themes[currentThemeName].Outline
local ThemeText = themes[currentThemeName].Text
local ThemePlaceholderText = themes[currentThemeName].PlaceholderText

function updateTheme()
    WindUI:AddTheme({
        Name = currentThemeName,
        Accent = ThemeAccent,
        Outline = ThemeOutline,
        Text = ThemeText,
        PlaceholderText = ThemePlaceholderText
    })
    WindUI:SetTheme(currentThemeName)
end

Tabs.CreateThemeTab:Colorpicker({
    Title = "Background Color",
    Default = Color3.fromHex(ThemeAccent),
    Callback = function(color)
        ThemeAccent = color
    end
})

Tabs.CreateThemeTab:Colorpicker({
    Title = "Outline Color",
    Default = Color3.fromHex(ThemeOutline),
    Callback = function(color)
        ThemeOutline = color
    end
})

Tabs.CreateThemeTab:Colorpicker({
    Title = "Text Color",
    Default = Color3.fromHex(ThemeText),
    Callback = function(color)
        ThemeText = color
    end
})

Tabs.CreateThemeTab:Colorpicker({
    Title = "Placeholder Text Color",
    Default = Color3.fromHex(ThemePlaceholderText),
    Callback = function(color)
        ThemePlaceholderText = color
    end
})

Tabs.CreateThemeTab:Button({
    Title = "Update Theme",
    Callback = function()
        WindUI:AddTheme({
            Name = currentThemeName,
            Accent = ThemeAccent,
            Outline = ThemeOutline,
            Text = ThemeText,
            PlaceholderText = ThemePlaceholderText
        })
        WindUI:SetTheme(currentThemeName)
        WindUI:Notify({
            Title = "Still working on it",
            Content = "soon '"..currentThemeName.."' soon",
            Duration = 3,
            Icon = "check-circle"
        })
    end
})
